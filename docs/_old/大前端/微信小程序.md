# 微信小程序

## 项目结构

```shell
.
├── miniprogram
│   ├── app.json # 全局配置文件
│   ├── app.less # 全局样式文件
│   ├── app.ts   # 启动文件
│   ├── pages
│   │   ├── index
│   │   │   ├── index.json # 配置文件
│   │   │   ├── index.less # 样式文件
│   │   │   ├── index.ts   # 业务文件
│   │   │   └── index.wxml # 模板文件
│   │   └── logs
│   │       ├── logs.json
│   │       ├── logs.ts
│   │       ├── logs.wxml
│   │       └── logs.wxss
│   ├── sitemap.json
│   └── utils
│       └── util.ts
├── package.json
├── project.config.json # 环境配置文件
├── project.private.config.json
├── tsconfig.json
└── typings
    ├── index.d.ts
    └── types
        ├── index.d.ts
        └── wx
            ├── index.d.ts
            ├── lib.wx.api.d.ts
            ├── lib.wx.app.d.ts
            ├── lib.wx.behavior.d.ts
            ├── lib.wx.cloud.d.ts
            ├── lib.wx.component.d.ts
            ├── lib.wx.event.d.ts
            └── lib.wx.page.d.ts
```

### app.json

```json
{
  "pages": [ // 注册页面
    "pages/index/index", 
    "pages/logs/logs"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#fff", // 导航条颜色
    "navigationBarTitleText": "Weixin",			// 导航条文字
    "navigationBarTextStyle": "black"				// 导航条文字颜色
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
```

### app.less

设置全局样式

```less
page { // 小程序会给所有页面包含一个page标签，可以通过全局样式统一设置
  font-family: "PingFangSC-Thin";
  font-size: 32rpx; // rpx单位可以实现机型的自适应
}
```

## 页面与布局

### 弹性布局

* 设置组件的样式为`display: flex;`，组件是弹性容器。
* 弹性容器中的组件，为属性`flex item`，无块状特性。

```less
.container {
  display: flex;
  flex-direction: column; // 设置排列方向，column-reverse 设置倒序属性
  justify-content: start; // 设置对齐方向，倒序时对齐方向会逆转。
  justify-content: space-between; // 平均分布
  justify-content: space-around; // 等距分布
  justify-content: space-evenly; // 间隔相等
}
```

* 主轴和交叉轴：`flex-direction: column` 主轴为垂直方向，交叉轴为水平方向；`flex-direction: row` 主轴为水平方向，交叉轴为垂直方向；使用`x-reverse` 轴方向会发生逆转。

```less
.container {
  display: flex;
  flex-direction: column; 
  justify-content: center; // 控制主轴布局
  align-items: center; // 控制交叉轴布局
  height: 400px;
  flex-wrap: wrap; // 换行
}
```

## 组件

### 组件定义

```shell
├── miniprogram
│   ├── components
│   │   └── like # 自定义组件
│   │       ├── index.json
│   │       ├── index.less
│   │       ├── index.ts
│   │       └── index.wxml
```

#### 模板

* `{{}}` 表示代码块，`src="{{like ? yesSrc : noSrc}}"` 属性中指定代码块需要使用引号，`<text>{{count}}</text> ` 标签中使用代码块，直接引用。
* `bindtap="onLike"` 绑定操作函数
* `class="container"` 指定样式

```vue
<view bindtap="onLike" class="container">
  <image src="{{like ? yesSrc : noSrc}}" />
  <text>{{count}}</text> 
</view>
```

#### 样式

```less
.container { // 定义样式
  display: inline-flex;
  flex-direction: row;
  padding: 10rpx;

  image {
    width: 32rpx;
    height: 28rpx;
  }

  text {
    font-size: 24rpx;
    line-height: 24rpx;
    color: #bbbbbb;
    position: relative;
    bottom: 10rpx;
    left: 6rpx;
  }
}
```

#### 业务

```typescript
Component({
  // 组件的属性列表，组件的属性可以从外部向组件内部传递。
  properties: {
    like: {
      type: Boolean,
    },

    count: {
      type: Number,
    }
  },

  // 组件的初始数据
  data: <{yesSrc: string, noSrc: string}>{ // 定义数据类型
    yesSrc: './images/like.png',
    noSrc: './images/like@dis.png',
  },

  // 组件的方法列表
  methods: {
    onLike(event: any) {
      let {like, count} = this.properties
      count = like ? count - 1 : count + 1
      this.setData({count, like: !like}) // 通过 setData 查找实现数据更新，可以更新 properties，也可以更新 data
  }
})
```

### 组件使用

在 `page.json` 文件中声明组件

```json
{
  "usingComponents": {
    "like": "../../components/like/index" // "组件名称": "组件路径"
  }
}
```

## 页面

页面使用类似组件，定义在pages文件夹中。

### 页面周期

```typescript
Page({
  // 生命周期函数--监听页面加载
  onLoad() { }, // 向服务器发送请求获得数据

  // 生命周期函数--监听页面初次渲染完成
  onReady() { },

  // 生命周期函数--监听页面显示
  onShow() { },

  // 生命周期函数--监听页面隐藏
  onHide() { },

  // 生命周期函数--监听页面卸载
  onUnload() { },

  // 页面相关事件处理函数--监听用户下拉动作
  onPullDownRefresh() { },

  // 页面上拉触底事件的处理函数
  onReachBottom() { },

  // 用户点击右上角分享
  onShareAppMessage() { }
})
```

## 请求

使用 `wx.request` 发送请求

* 即使返回代码是 `4xx` 返回也算请求成功，需要单独处理；请求失败只发生在网络断开时；

```typescript
wx.request({
  url: '', // 请求路径
  
  header: { // 请求头
    appKey: ''
  },
  
  success: (res) => { // 成功回调
  },
  
  fail: (err) => { // 失败回调
	}
})
```

### 请求封装

将微信基础请求封装成完成的类

```js
class HTTP {
  constructor() {
    this.baseRestUrl = config.api_blink_url
  }

  request(params) { // http 请求类, 当noRefech为true时，不做未授权重试机制
    var that = this
    var url = this.baseRestUrl + params.url;

    if (!params.method) {
      params.method = 'GET';
    }
    wx.request({
      url: url,
      data: params.data,
      method: params.method,
      header: {
        'content-type': 'application/json',
        'appkey':config.appkey
      },
      success: function (res) {
        // 判断以2（2xx)开头的状态码为正确
        // 异常不要返回到回调中，就在request中处理，记录日志并showToast一个统一的错误即可
        var code = res.statusCode.toString();
        var startChar = code.charAt(0);
        if (startChar == '2') {
          params.success && params.success(res.data);
        } else {
          params.error && params.error(res);
        }
      },
      fail: function (err) {
        params.fail && params.fail(err)
      }
    });
  }
};
```

### 数据模型

将每个页面的请求封装在 `models` 文件夹中，定义不同的 `model` 文件，`model` 文件继承请求基类；封装一个页面的所有请求。

```js
class ClassicModel extends HTTP{
  prefix = 'classic'

  constructor() {
    super()
  }

  getLatest(sCallback){
    this.request({
      url:'classic/latest',
      success:(data)=>{
          // 如果不用箭头函数，this将指代不正确
          let key = this._fullKey(data.index)
          wx.setStorageSync(key, data)
          this._setLatestIndex(data.index)
          sCallback(data)
        }
    })
  }

  getPrevious(index, sCallback) { }

  getNext(index, sCallback) { }

  getById(cid, type, success){
    let params = {
      url:'classic/'+type+'/' + cid,
      success:success
    }
    this.request(params)
  }

  isLatest(index){
    let key = this._fullKey('latest-' + index)
    let latestEpsoide = wx.getStorageSync(key)
    if(latestEpsoide){
      if (index == latestEpsoide){
        return true
      }
    }
    else return false
  }

  isFirst(index){
    if (index==1){
      return true
    }
    else return false
  }

  getMyFavor(success){
    let params={
      url:'classic/favor',
      success:success
    }
    this.request(params)
  }
}

export {ClassicModel}
```

