# 节点操作

<img src="https://raw.githubusercontent.com/hughxusu/lesson-web/develop/images/d-js/20119743rDMoKM5GAm.png" style="zoom:50%;" />

DOM节点：DOM树里每一个内容都称之为节点

节点类型

* 元素节点：所有的标签比如`body`、 `div`、`html`是根节点
* 属性节点：所有的属性比如`href`
* 文本节点：所有的文本
* 其他

## 查找节点

### 查找父节点

`.parentNode`属性。返回最近一级的父节点，找不到返回为`null`。

```html
<body>
    <div class="pic">
        <span class="close">
        </span>
    </div>
</body>
<script>
    let close_btn = document.querySelector('.close')
    close_btn.addEventListener('click', function () {
        this.parentNode.style.display = 'none'
    })
</script>
```

### 查找子节点

* `.childNodes`获得所有子节点、包括文本节点(空格、换行)、注释节点等。
* `.children`仅获得所有元素节点，返回的还是一个伪数组。

```html
<body>
    <button>click me</button>
    <ul>
        <li>javascript</li>
        <li>css</li>
        <li>html</li>
        <li>python</li>
    </ul>
</body>
<script>
    let btn = document.querySelector('button')
    let ul = document.querySelector('ul')

    console.log(ul.children)
    ul.children[0].style.color = 'green'

    btn.addEventListener('click', function () {
        for (let i = 0; i < ul.children.length; i++) {
            ul.children[i].style.color = 'red'
        }
    })
</script>
```

### 查找兄弟节点

* `.nextElementSibling`返回下一个兄弟节点找不到返回为`null`。
* `.previousElementSibling`返回上一个兄弟节点找不到返回为`null`。

```html
<body>
    <button>click me</button>
    <ul>
        <li>html</li>
        <li class="two">css</li>
        <li>javascript</li>
        <li>python</li>
    </ul>
</body>
<script>
    let btn = document.querySelector('button')
    let two = document.querySelector('.two')
    
    console.log(two.nextElementSibling)
    console.log(two.previousElementSibling)
    
    btn.addEventListener('click', function () {
        two.nextElementSibling.style.color = 'red'
        two.previousElementSibling.style.color = 'red'
    })
</script>
```

### 增加节点

操作步骤：

1. 创建节点`document.createElement(tag)`
   * `tag`标签名。
2. 添加节点。创建后的节点只有添加到DOM树中，才能被看见。
   * `div.appendChild(obj)`插入到父元素的最后。
   * `div.insertBefore(obj, aim)`插入到父元素中某个子元素（`aim`）的前面。

```html
<body>
    <div>
        <button id="header">添加标题</button>
        <button id="content">添加内容</button>
    </div>
    <div class="root">
        <div class="content"></div>
    </div>
</body>
<script>
    let addHeader = document.querySelector('#header')
    let addContent = document.querySelector('#content')

    let root = document.querySelector('.root')
    let content = document.querySelector('.content')

    addHeader.addEventListener('click', function () {
        let h1 = document.createElement('h1')
        h1.innerHTML = '宿建德江'
        root.insertBefore(h1, root.children[0])
    })


    addContent.addEventListener('click', function () {
        let div = document.createElement('div')
        div.innerHTML = `
            移舟泊烟渚，<br>
            日暮客愁新。<br>
            野旷天低树，<br>
            江清月近人。
        `
        div.className = 'box'
        content.appendChild(div)
    })
</script>
```

### 克隆节点

`div.cloneNode(flag)`会克隆出跟原标签一样的节点。

*  `flag`：`true`表示克隆后代节点，`false`不克隆后代节点。

```html
<body>
    <button>copy it</button>
    <ul class="root">
        <li>
            <h3>明月出天山，苍茫云海间。</h3>
        </li>
    </ul>
</body>
<script>
    let button = document.querySelector('button')
    let root = document.querySelector('.root')
    let li = root.children[0]
    
    button.addEventListener('click', function () {
        let newli = li.cloneNode(true)
        root.appendChild(newli)
    })
</script>
```

### 删除节点

在DOM操作中，如果要删除元素，必须通过其父元素删除`father.removeChild(obj)`删除子节点。

```html
<body>
    <button>remove it</button>
    <div>
        <p>云母屏风烛影深，</p>
        <p>长河渐落晓星沉。</p>
        <p>嫦娥应悔偷灵药，</p>
        <p>碧海青天夜夜心。</p>
    </div>
</body>
<script>
    const btn = document.querySelector('button')
    const div = document.querySelector('div')
    btn.addEventListener('click', () => {
        div.removeChild(div.children[0])
    })
</script>
```

* 如不存在父子关系则删除不成功。
* 删除节点：DOM树中移除该节点；隐藏节点（`display:none`）：DOM树中节点还存在。

`father.remove()`移除所有子元素

```js
const btn = document.querySelector('button')
const div = document.querySelector('div')
btn.addEventListener('click', () => {
    div.remove()
}
```

## 时间对象

可以使用`new`关键词来实例化一个对象，这个过程称为实例化。

```js
let obj = {}
let newObj = new Object()

console.log(`obj is ${typeof obj}`)
console.log(`newObj is ${typeof newObj}`)
```

`Date()`是JavaScript中用于处理时间的内置对象，称为时间对象，需通过`new`关键字来创建其实例。

```js
let date = new Date() // 返回当前时间
console.log(date)
let last = new Date('2000-1-1 00:00:00') // 返回指定的时间
console.log(last)
```

时间对象常用函数

| 方法            | 作用               | 说明                 |
| --------------- | ------------------ | -------------------- |
| `getFullYear()` | 获得年份           | 获取四位年份         |
| `getMonth()`    | 获得月份           | 取值为 0 ~ 11        |
| `getDate()`     | 获取月份中的每一天 | 不同月份取值也不相同 |
| `getDay()`      | 获取星期           | 取值为 0 ~ 6         |
| `getHours()`    | 获取小时           | 取值为 0 ~ 23        |
| `getMinutes()`  | 获取分钟           | 取值为 0 ~ 59        |
| `getSeconds()`  | 获取秒             | 取值为 0 ~ 59        |

打印当前的时间

```html
<body>
    <h1></h1>
</body>
<script>
    let arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']
    let h1 = document.querySelector('h1')
    getTime()
    setInterval(getTime, 1000)
    function getTime() {
        let date = new Date()
        let year = date.getFullYear()
        let month = (date.getMonth() + 1).toString().padStart(2, '0')
        let date1 = date.getDate().toString().padStart(2, '0')
        let hour = date.getHours().toString().padStart(2, '0')
        let min = date.getMinutes().toString().padStart(2, '0')
        let sec = date.getSeconds().toString().padStart(2, '0')
        let day = date.getDay()
        h1.innerText = `今天是： ${year}年${month}月${date1}日 ${hour}:${min}:${sec} ${arr[day]}`
    }
</script>
```

* 为了避免刷新延迟问题，先调用一次`getTime`函数，然后在启动定时器。

### 时间戳

时间戳：是指1970年01月01日00时00分00秒起至现在的毫秒数，它是一种特殊的计量时间的方式。时间戳可用用于绝对时间的计算。获取时间戳的方法：

1.  `date.getTime()`

```js
let date = new Date()
let timestamp = date.getTime()
console.log(timestamp)
```

2. `+new Date()` 

```js
// 获取具体时间点的时间戳
let timestamp1 = +new Date('2000-1-1 00:00:00')
console.log(timestamp1)
```

3. `Date.now()`无需实例化

```js
let timestamp2 = Date.now()
console.log(timestamp2)
```

* 只能获得此刻的时间戳， 而前面两种可以返回指定时间的时间戳。

新年倒计时

```html
<body>
    <h1 id="timer"></h1>
</body>
<script>
    let h1 = document.querySelector('#timer')
    let year = new Date().getFullYear()
    let endTime = +new Date(`${year}-12-31 11:59:59`)
    timer()
    setInterval(timer, 1000)
    function timer() {
        let now = Date.now()
        let count = (endTime - now) / 1000
        let d = parseInt(count / 60 / 60 / 24).toString().padStart(2, '0')
        let h = parseInt(count / 60 / 60 % 24).toString().padStart(2, '0')
        let m = parseInt(count / 60 % 60).toString().padStart(2, '0')
        let s = parseInt(count % 60).toString().padStart(2, '0')
        h1.innerHTML = `距离${year + 1}年还有: ${d}天${h}小时${m}分${s}秒`
    }
</script>
```

## 重绘和回流

<img src="https://raw.githubusercontent.com/hughxusu/lesson-web/develop/images/d-js/2925639041-622ab7b200c77_fix732.png" style="zoom:80%;" />

* 解析（Parser）HTML，生成DOM树（DOM Tree）
* 同时解析（Parser）CSS，生成样式规则（Style Rules）
* 根据DOM树和样式规则，生成渲染树（Render Tree）
* 进行布局Layout（回流/重排）：根据生成的渲染树，得到节点的几何信息（位置，大小）
* 进行绘制Painting（重绘）：根据计算和获取的信息进行整个页面的绘制
* Display：展示在页面上

回流：当 Render Tree 中部分或者全部元素的尺寸、结构、布局等发生改变时，浏览器就会重新渲染部分或全部文档的过程称为回流。

重绘：由于节点(元素)的样式的改变并不影响它在文档流中的位置和文档布局时（比如：color、background-color、outline等）, 称为重绘。

> [!warning]
>
> 重绘不一定引起回流，而回流一定会引起重绘。

会导致回流的操作：

* 页面的首次刷新。
* 浏览器的窗口大小发生改变。
* 元素的大小或位置发生改变。
* 改变字体的大小。
* 内容的变化（如：input框的输入，图片的大小）
* 激活css伪类（如：hover）
* 脚本操作DOM（添加或者删除可见的DOM元素）

```js
let s = document.body.style
s.padding = '20px' // 回流
s.border = '1px solid #ccc' // 回流
s.color = '#333' // 重绘
s.backgroundColor = '#f4f4f4' // 重绘
s.fontSize = '16px' // 回流
```

> [!warning]
>
> 影响到布局了，就会有回流。

## 综合案例

<img src="https://raw.githubusercontent.com/hughxusu/lesson-web/develop/images/d-js/Xnip2025-10-25_19-16-22.jpg" style="zoom:30%;" />

使用WebApi优化上面案例

```html
<body>
    <ul></ul>
</body>
<script>
    let data = [
        {
            name: '罗马, 意大利',
            date: '2020年6月12日至24日',
            price: '$349',
            img: 'img1.png'
        },
        {
            name: '纽约, 美国',
            date: '2020年6月12日至24日',
            price: '$200',
            img: 'img2.png'
        },
        {
            name: '巴塞罗那, 西班牙',
            date: '2020年6月12日至24日',
            price: '$95',
            img: 'img3.png'
        },
        {
            name: '巴黎, 法国',
            date: '2020年6月12日至24日',
            price: '$1200',
            img: 'img4.png'
        },
        {
            name: 'San Francisco, 美国',
            date: '2020年6月12日至24日',
            price: '$480',
            img: 'img5.png'
        },
        {
            name: 'Amesbury, UK',
            date: '2020年6月12日至24日',
            price: '$569',
            img: 'img6.png'
        },
        {
            name: 'Versailles, 法国',
            date: '2020年6月12日至24日',
            price: '$100',
            img: 'img7.png'
        },
        {
            name: 'Venice, 意大利',
            date: '2020年6月12日至24日',
            price: '$99',
            img: 'img8.png'
        }
    ]

    let ul = document.querySelector('ul')
    let path = 'https://raw.githubusercontent.com/hughxusu/lesson-web/refs/heads/develop/res/travel/'
    for (let i = 0; i < data.length; i++) {
        let li = document.createElement('li')
        li.innerHTML = `
            <div>
                <h3>${data[i].name}</h3>
                <p>${data[i].date}</p>
                <h2>${data[i].price}</h2>
            </div>
            <img src="${path}${data[i].img}" alt="">
        `
        ul.appendChild(li)
    }
</script>
```

