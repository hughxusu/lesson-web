# 事件对象

事件对象封装了事件触发的相关信息，绑定事件的回调函数，第一个参数就是事件对象，一般命名为`event`、`ev`或`e`。

```html
<button>Click me</button>
<script>
    let btn = document.querySelector('button')
    btn.addEventListener('click', function (e) {
        console.log(e)
    })
</script>
```

## 事件对象的属性

### 事件类型

`type`获取当前的事件类型。

```html
<body>
    <div></div>
</body>
<script>
    let div = document.querySelector('div')
    div.addEventListener('mouseenter', function (e) {
        console.log(e.type)
    })
</script>
```

常见数据事件

| 事件分类     | 事件类型     | 说明                                                         | 常见使用场景                      |
| ------------ | ------------ | ------------------------------------------------------------ | --------------------------------- |
| **鼠标事件** | `click`      | 鼠标左键单击元素                                             | 按钮点击、链接跳转、表单提交触发  |
|              | `dblclick`   | 鼠标左键双击元素                                             | 双击编辑、双击放大图片            |
|              | `mouseover`  | 鼠标指针移入元素（包含子元素，会冒泡）                       | hover 效果、显示下拉菜单          |
|              | `mouseout`   | 鼠标指针移出元素（包含子元素，会冒泡）                       | 取消 hover 效果、隐藏下拉菜单     |
|              | `mouseenter` | 鼠标指针移入元素（不包含子元素，不冒泡）                     | 精准 hover 效果（避免子元素触发） |
|              | `mouseleave` | 鼠标指针移出元素（不包含子元素，不冒泡）                     | 精准取消 hover 效果               |
|              | `mousedown`  | 鼠标按下（任意键）                                           | 拖拽开始、绘制功能触发            |
|              | `mouseup`    | 鼠标松开（任意键）                                           | 拖拽结束、绘制功能停止            |
| **键盘事件** | `keydown`    | 键盘按键按下（持续按住会重复触发，包含功能键）               | 快捷键监听（如 Ctrl+S）、游戏控制 |
|              | `keyup`      | 键盘按键松开                                                 | 快捷键释放、输入完成监听          |
|              | `keypress`   | 键盘按下并释放（仅支持字符键，已逐步废弃，建议用 `keydown` 替代） | 字符输入监听（兼容性场景）        |
| **表单事件** | `input`      | 表单元素值发生变化（实时触发，支持输入、粘贴、拖拽等）       | 实时搜索、输入长度限制、表单验证  |
|              | `blur`       | 元素失去焦点（不冒泡）                                       | 输入框失焦时验证、隐藏输入提示    |

### 光标位置

* `clientX`和`clientY`获取光标相对于浏览器可见窗口左上角的位置。
* `offsetX`和`offsetY`获取光标相对于当前DOM元素左上角的位置。
* `pageX`和`pageY`获得光标相对于当前文档左上角的位置。

![](https://raw.githubusercontent.com/hughxusu/lesson-web/develop/images/d-js/blog.a02e249b.png)

```html
<body>
    <div></div>
</body>
<script>
    document.addEventListener('click', function (e) {
        console.log('clientX:' + e.clientX, 'clientY:' + e.clientY)
        console.log('pageX:' + e.pageX, 'pageY:' + e.pageY)
        console.log('offsetX:' + e.offsetX, 'offsetY:' + e.offsetY)
    })
</script>
```

图片跟随鼠标移动

```html
<body>
    <img src="https://raw.githubusercontent.com/hughxusu/lesson-web/develop/res/others/scope.png">
</body>
<script>
    let img = document.querySelector('img')
    document.addEventListener('mousemove', function (e) {
        img.style.left = e.pageX - 48 + 'px'
        img.style.top = e.pageY - 48 + 'px'
    })
</script>
```

### 键盘值

`key`用户按下的键盘键的值。

```html
<body>
    <input type="text" id="inputText">
</body>
<script>
    const inputText = document.querySelector('#inputText');
    inputText.addEventListener('keydown', function (event) {
        console.log(event.key);
    });
</script>
```

任务清单

```html
<body>
    <div id="container">
        <h3>请输入你的任务：</h3>
        <input type="text" id="inputText">
        <ul id="displayText"></ul>
    </div>
</body>
<script>
    let inputText = document.querySelector('#inputText');
    let displayText = document.querySelector('#displayText');
    inputText.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
            let newText = document.createElement('li');
            newText.innerHTML = `
                <div>
                    <input type="checkbox" class="ok" style="margin-right: 12px;">
                    <span>${inputText.value}</span>
                </div>
                <button>
                    <img src="https://raw.githubusercontent.com/hughxusu/lesson-web/develop/res/others/delete.png" class="delete">
                </button>
                
            `
            newText.classList.add('item');
            displayText.prepend(newText);
            inputText.value = '';
        }

        let okBtn = document.querySelectorAll('.ok');
        for (let i = 0; i < okBtn.length; i++) {
            okBtn[i].addEventListener('click', function () {
                if (this.checked) {
                    this.parentElement.parentElement.style.textDecoration = 'line-through';
                } else {
                    this.parentElement.parentElement.style.textDecoration = 'none';
                }
            });
        }

        let deleteBtn = document.querySelectorAll('.delete');
        for (let i = 0; i < deleteBtn.length; i++) {
            deleteBtn[i].addEventListener('click', function () {
                this.parentElement.parentElement.remove();
            });
        }
    });

    let deleteBtn = document.querySelectorAll('.delete');
</script>
```

## 事件流

事件流指的是事件完整执行过程中的流动路径。当触发事件时，会经历两个阶段，分别是捕获阶段和冒泡阶段。

* 事件冒泡：当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。
  * 即一个元素触发事件后，会依次向上调用所有父级元素的同名事件。
  * 事件冒泡是默认存在的。

* 事件捕获：从DOM的根元素开始去执行对应的事件。
  * 事件捕获需要写对应代码才能看到效果。


<img src="https://raw.githubusercontent.com/hughxusu/lesson-web/develop/images/d-js/9NmV6c2.png" alt="img" style="zoom:90%;" />

```html
<body>
    <div class="root">
        <div class="inner">
        </div>
    </div>
</body>

<script>
    let root = document.querySelector('.root')
    root.addEventListener('click', function () {
        alert('this is skyblue')
    })

    let inner = document.querySelector('.inner')
    inner.addEventListener('click', function () {
        alert('this is purple')
    })
    
    document.addEventListener('click', function () {
        alert('this is document')
    })
</script>
```

使用事件捕获：设置`addEventListener`第三个参数为`true`代表捕获阶段触发。

> [!warning]
>
> 若是用L0事件监听，如：`.onclick`。则只有冒泡阶段，没有捕获。

```js
let root = document.querySelector('.root')
root.addEventListener('click', function () {
    alert('this is skyblue')
}, true)

let inner = document.querySelector('.inner')
inner.addEventListener('click', function () {
    alert('this is purple')
}, true)

document.addEventListener('click', function () {
    alert('this is document')
}, true)
```

### 阻止事件流动

如果不想事件影响父级元素，可以阻止事件流动。使用方法`event.stopPropagation()`，该方法绑定在鼠标事件上。

```js
let root = document.querySelector('.root')
root.addEventListener('click', function () {
    alert('this is skyblue')
})

let inner = document.querySelector('.inner')
inner.addEventListener('click', function (e) {
    alert('this is purple')
    e.stopPropagation()
})

document.addEventListener('click', function () {
    alert('this is document')
})
```

该方法在事件捕获阶段也可以使用。

```js
let root = document.querySelector('.root')
root.addEventListener('click', function () {
    alert('this is skyblue')
}, true)

let inner = document.querySelector('.inner')
inner.addEventListener('click', function () {
    alert('this is purple')
}, true)

document.addEventListener('click', function (e) {
    alert('this is document')
    e.stopPropagation()
}, true)
```

鼠标经过事件：

* `mouseover`和`mouseout`会有冒泡效果。

```html
<body>
    <div class="root">
        <div class="inner"></div>
    </div>
    <div class="show"></div>
</body>
<script>
    let show = document.querySelector('.show')
    let root = document.querySelector('.root')
    root.addEventListener('mouseover', function (e) {
        let ele = document.createElement('h3')
        ele.innerHTML = 'move in skyblue'
        show.appendChild(ele)
    })

    let inner = document.querySelector('.inner')
    inner.addEventListener('mouseover', function (e) {
        let ele = document.createElement('h3')
        ele.innerHTML = 'move in purple'
        show.appendChild(ele)
    })    
</script>
```

* `mouseenter`和`mouseleave`没有冒泡效果。

```js
let root = document.querySelector('.root')
root.addEventListener('mouseenter', function (e) {
    let ele = document.createElement('h3')
    ele.innerHTML = 'move in skyblue'
    show.appendChild(ele)
})

let inner = document.querySelector('.inner')
inner.addEventListener('mouseenter', function (e) {
    let ele = document.createElement('h3')
    ele.innerHTML = 'move in purple'
    show.appendChild(ele)
})
```

### 阻止默认行为

阻止标签的默认行为，如：跳转链接等。可以使用`event.preventDefault()`，该方法绑定在鼠标事件上。

```html
<body>
    <a href="http://www.baidu.com">跳转到百度</a>
</body>
<script>
    let a = document.querySelector('a')
    a.addEventListener('click', function (e) {
        e.preventDefault()
    })
</script>
```

### 事件注册的区别

事件监听（L0）传统`onXXX`注册

* 同一个元素相同事件，后面注册的事件会覆盖前面注册。
* 直接使用`null`覆盖偶就可以实现事件的解绑。
* 都是冒泡阶段执行的。

事件监听（L2）使用`addEventListener`

* 同一个元素相同事件，后面注册的事件不会覆盖前面注册的事件。
* 可以通过第三个参数去确定是在冒泡或者捕获阶段执行。
* 必须使用`removeEventListener`解绑事件。
* 匿名函数无法被解绑。

```html
<body>
    <div class="root">
        <div class="left">
            <h3>onclick</h3>
            <div>
                <button id="action">
                    click me
                </button>
            </div>
            <div>
                <button id="un-action">
                    unbind
                </button>
            </div>
        </div>
        <div class="right">
            <h3>addEventListener</h3>
            <div>
                <button id="listener">
                    click me
                </button>
            </div>
            <div>
                <button id="un-listener">
                    unbind
                </button>
            </div>
        </div>
    </div>
</body>
<script>
    let btnAction = document.getElementById('action')
    let btnUnAction = document.getElementById('un-action')
    btnAction.onclick = function () {
        alert('星垂平野阔')
    }
    btnAction.onclick = function () {
        alert('月涌大江流')
    }
    btnUnAction.onclick = function () {
        btnAction.onclick = null
    }

    function listener1() {
        alert('星垂平野阔')
    }
    function listener2() {
        alert('月涌大江流')
    }
    let btnListener = document.getElementById('listener')
    let btnUnListener = document.getElementById('un-listener')
    btnListener.addEventListener('click', listener1)
    btnListener.addEventListener('click', listener2)
    btnUnListener.onclick = function () {
        btnListener.removeEventListener('click', listener1)
        btnListener.removeEventListener('click', listener2)
    }
</script>
```

## 事件委托

事件委托是利用事件冒泡的特点， 给父元素添加事件。

* 操作子元素可以触发父元素的事件。

* 通过`event.target`可以获得真正触发事件的元素。

```html
<body>
    <ul>
        <li><h2>君问归期未有期，</h2></li>
        <li><h2>巴山夜雨涨秋池。</h2></li>
        <li><h2>何当共剪西窗烛，</h2></li>
        <li><h2>却话巴山夜雨时。</h2></li>
    </ul>
</body>
<script>
    let ul = document.querySelector('ul')
    ul.addEventListener('click', function (e) {
        alert(e.target.innerHTML)
    })
</script>
```

> [!warning]
>
> 事件委托，委托给父元素。

任务清单案例存在的问题：使用循环绑定事件数组时会将事件绑定多次。

```js
let inputText = document.querySelector('#inputText');
let displayText = document.querySelector('#displayText');
inputText.addEventListener('keydown', function (event) {
    if (event.key === 'Enter') {
        let newText = document.createElement('li');
        newText.innerHTML = `
            <div>
                <input type="checkbox" class="ok" style="margin-right: 12px;">
                <span>${inputText.value}</span>
            </div>
            <button>
                <img src="https://raw.githubusercontent.com/hughxusu/lesson-web/develop/res/others/delete.png" class="delete">
            </button>

        `
        newText.classList.add('item');
        displayText.prepend(newText);
        inputText.value = '';
    }
});

displayText.addEventListener('click', function (event) {
    if (event.target.classList.contains('ok')) {
        if (event.target.checked) {
            event.target.parentElement.parentElement.style.textDecoration = 'line-through';
        } else {
            event.target.parentElement.parentElement.style.textDecoration = 'none';
        }
    } else if (event.target.classList.contains('delete')) {
        event.target.parentElement.parentElement.remove();
    }
});
```

* `.classList.contains`方法可以检测元素是否包含某个类。

> [!tip]
>
> Tab栏切换如何使用事件委托来解决。

## 综合案例

成绩录入单

```html
<body>
    <h1>JavaScript编程课程成绩录入</h1>
    <div class="info">
        学号：<input type="text" class="stuId">
        姓名：<input type="text" class="uname">
        班级：<select name="city" id="" class="class">
            <option value="信息与计算科学1班">信息与计算科学1班</option>
            <option value="信息与计算科学2班">信息与计算科学2班</option>
        </select>
        成绩：<input type="text" class="score">
        <button class="add">录入</button>
    </div>
    <table>
        <thead>
            <tr>
                <th>序号</th>
                <th>学号</th>
                <th>姓名</th>
                <th>班级</th>
                <th>成绩</th>
                <th>操作</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
</body>
<script>
    let arr = [
        { stuId: 1001, uname: '张三', class: '信息与计算科学1班', score: 85 },
        { stuId: 1001, uname: '李四', class: '信息与计算科学2班', score: 90 },
    ]

    let tbody = document.querySelector('tbody')
    function render() {
        // 每次刷新页面前清空节点
        tbody.innerHTML = ''
        for (let i = 0; i < arr.length; i++) {
            let tr = document.createElement('tr')
            tr.innerHTML = `
                <td>${i + 1}</td>
                <td>${arr[i].stuId}</td>
                <td>${arr[i].uname}</td>
                <td>${arr[i].class}</td>
                <td>${arr[i].score}</td>
                <td>
                    <a href="javascript:" id="${i}">删除</a>
                </td>
            `
            tbody.appendChild(tr)
        }
    }
    render()

    let stuId = document.querySelector('.stuId')
    let uname = document.querySelector('.uname')
    let clazz = document.querySelector('.class')
    let score = document.querySelector('.score')
    let add = document.querySelector('.add')
    
    add.addEventListener('click', function () {
        arr.push({
            stuId: Number(stuId.value),
            uname: uname.value,
            class: clazz.value,
            score: score.value,
        })
        render()
    })

    // 事件委托，用于删除操作
    tbody.addEventListener('click', function (e) {
        // 判断是否点击的是a标签
        if (e.target.tagName === 'A') {
            arr.splice(e.target.id, 1)
            render()
        }
    })
</script>
```

* 基于数据内容进行页面渲染。
* `tbody.innerHTML = ''`每次刷新页面前清空节点。
* `<a href="javascript:" id="${i}">`这里`href="javascript:"`阻止了链接的默认行为。
* 将删除操作委托给`tbody`。
